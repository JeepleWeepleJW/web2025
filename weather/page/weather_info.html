<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Weather Info</title>
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <script defer src="../js/bootstrap.min.js"></script>
    <script defer>
        document.addEventListener('DOMContentLoaded', () => {
            const params     = new URLSearchParams(window.location.search);
            const code       = params.get('code');
            const modalEl    = document.getElementById('invalidModal');
            const modalTitle = modalEl.querySelector('.modal-title');
            const modalBody  = modalEl.querySelector('.modal-body');
            const closeBtn   = document.getElementById('closeBtn');
            const confirmBtn = document.getElementById('confirmBtn');
            const contentEl  = document.getElementById('content');
            const spinnerEl  = document.getElementById('loadingSpinner');

            function redirectToWeather() {
                window.location.href = 'weather.html';
            }
            function showInvalidModal() {
                modalTitle.textContent = '잘못된 접근';
                modalBody.textContent  = '잘못된 접근입니다.';
                new bootstrap.Modal(modalEl).show();
                closeBtn.addEventListener('click', redirectToWeather);
                confirmBtn.addEventListener('click', redirectToWeather);
            }
            if (!code) { showInvalidModal(); return; }

            const skyMap = { '1':'맑음', '3':'구름많음', '4':'흐림' };

            // ■ 로딩 스피너 표시
            spinnerEl.classList.remove('d-none');

            // 1) 주소 JSON 로드
            fetch('../data/weather_address.json')
                .then(r => r.json())
                .then(data => {
                    const select_address = data.find(item => String(item.administrative_code) === code);
                    if (!select_address) { showInvalidModal(); throw 'no-address'; }

                    // 발표시각 계산, 좌표 준비
                    const { base_date, base_time } = computeBaseDateTime();
                    const nx = Math.round(select_address.lat_decimal);
                    const ny = Math.round(select_address.lon_decimal);
                    const serviceKey = 'XBi6TBHmrnZ0J1zY7Xu4PpdsrKrOXjxRm8l7LSDxsdPpF0RMvZUVVhQF1nYQRQ87en0GXMRwD4y/XcPkr+BXAw==';
                    const apiUrl = new URL('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst');
                    apiUrl.searchParams.append('serviceKey', serviceKey);
                    apiUrl.searchParams.append('numOfRows', 2000);
                    apiUrl.searchParams.append('pageNo', 1);
                    apiUrl.searchParams.append('dataType', 'JSON');
                    apiUrl.searchParams.append('base_date', base_date);
                    apiUrl.searchParams.append('base_time', base_time);
                    apiUrl.searchParams.append('nx', nx);
                    apiUrl.searchParams.append('ny', ny);

                    return fetch(apiUrl.toString());
                })
                .then(res => {
                    if (!res.ok) throw 'api-error';
                    return res.json();
                })
                .then(json => {
                    const items = json.response?.body?.items?.item || [];
                    if (!items.length) {
                        contentEl.innerHTML = '<p>단기예보 정보가 없습니다.</p>';
                        return;
                    }

                    // 그룹핑 & 최신 데이터 추출
                    const byDate = {};
                    items.forEach(e => {
                        byDate[e.fcstDate] = byDate[e.fcstDate] || [];
                        byDate[e.fcstDate].push(e);
                    });
                    const latestByDate = {};
                    Object.keys(byDate).sort().forEach(date => {
                        const latestThis = {};
                        byDate[date].forEach(e => {
                            if (!latestThis[e.category] || e.fcstTime > latestThis[e.category].fcstTime) {
                                latestThis[e.category] = e;
                            }
                        });
                        latestByDate[date] = latestThis;
                    });

                    // 화면 렌더링
                    const heading = document.createElement('h4');
                    heading.textContent = '날짜별 최신 단기예보';
                    contentEl.appendChild(heading);

                    Object.keys(latestByDate).forEach(date => {
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'mb-4';
                        const title = document.createElement('h5');
                        title.textContent = `예보일자: ${date}`;
                        groupDiv.appendChild(title);

                        const ul = document.createElement('ul');
                        ul.className = 'list-group';

                        Object.values(latestByDate[date]).forEach(entry => {
                            const li = document.createElement('li');
                            li.className = 'list-group-item';
                            let val = entry.fcstValue;
                            if (entry.category === 'SKY') val = skyMap[val] || val;
                            li.textContent =
                                `예보시각: ${entry.fcstTime} | ` +
                                `카테고리: ${entry.category} | ` +
                                `예보값: ${val}`;
                            ul.appendChild(li);
                        });

                        groupDiv.appendChild(ul);
                        contentEl.appendChild(groupDiv);
                    });
                })
                .catch(err => {
                    if (err !== 'no-address') {
                        contentEl.innerHTML = '<p>단기예보조회 API 호출 중 오류가 발생했습니다.</p>';
                    }
                })
                .finally(() => {
                    // ■ 로딩 스피너 숨기기
                    spinnerEl.classList.add('d-none');
                });

            // helper: 발표일시 계산
            function computeBaseDateTime() {
                const now = new Date(), h = now.getHours(), m = now.getMinutes();
                const candidates = [
                    { hh:23, mm:0, str:'2300' },
                    { hh:20, mm:0, str:'2000' },
                    { hh:17, mm:0, str:'1700' },
                    { hh:14, mm:0, str:'1400' },
                    { hh:11, mm:0, str:'1100' },
                    { hh: 8, mm:0, str:'0800' },
                    { hh: 5, mm:0, str:'0500' },
                    { hh: 2, mm:0, str:'0200' }
                ];
                for (let c of candidates) {
                    if (h>c.hh || (h===c.hh && m>=10)) {
                        const y=now.getFullYear(), mmn=now.getMonth()+1, dd=now.getDate();
                        return {
                            base_date: `${y}${String(mmn).padStart(2,'0')}${String(dd).padStart(2,'0')}`,
                            base_time: c.str
                        };
                    }
                }
                const yst = new Date(now - 86400000),
                    y=yst.getFullYear(), mmn=yst.getMonth()+1, dd=yst.getDate();
                return {
                    base_date: `${y}${String(mmn).padStart(2,'0')}${String(dd).padStart(2,'0')}`,
                    base_time: '2300'
                };
            }
        });
    </script>
    <style>
        body {
            background-color: #ffffff;
            color: #000000;
            font-family: Arial, sans-serif;
            padding-top: 20px;
        }
    </style>
</head>
<body>
<!-- 로딩 스피너 (Bootstrap 유틸리티만 사용) -->
<div
        id="loadingSpinner"
        class="d-none position-fixed top-50 start-50 translate-middle d-flex justify-content-center align-items-center"
        style="z-index: 1050;"
>
    <div class="spinner-border text-dark" role="status">
        <span class="visually-hidden">로딩중...</span>
    </div>
</div>

<div class="container" id="content"></div>

<!-- 잘못된 접근 모달 -->
<div class="modal fade" id="invalidModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"></h5>
            </div>
            <div class="modal-body"></div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="closeBtn">닫기</button>
                <button type="button" class="btn btn-secondary" id="confirmBtn">확인</button>
            </div>
        </div>
    </div>
</div>
</body>
</html>